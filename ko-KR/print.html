<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title> - 카일루아 1.1.0 문서</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        
        <link rel="stylesheet" href="kailua.css">
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

        <!-- Custom JS script -->
        
        <script type="text/javascript" src="kailua.js"></script>
        

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="./overview.html">개요</a></li><li><a href="./classes.html"><strong>1.</strong> 클래스</a></li><li><ul class="section"><li><a href="./classes-gideros.html"><strong>1.1.</strong> 기데로스 지원</a></li></ul></li><li><a href="./internals.html"><strong>2.</strong> 내부</a></li><li class="affix"><a href="./license.html">라이선스</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">카일루아 1.1.0 문서</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html# 카일루아" id=" 카일루아"><h1>🌴 카일루아</h1></a>
<p><strong>카일루아</strong>는 <a href="https://www.lua.org/">루아</a> 프로그래밍 언어를 위한 실험적 타입 검사기 및 통합 개발 환경(IDE)입니다. (현재는 루아 5.1만 지원됩니다.)</p>
<p><strong><em>이 프로젝트는 매우 실험적이며 어떤 보장이나 지원도 제공하지 않습니다!</em></strong></p>
<a class="header" href="print.html#설치와 사용" id="설치와 사용"><h2>설치와 사용</h2></a>
<p>카일루아는 독립 검사기로도 쓸 수 있고 IDE 플러그인으로도 쓸 수 있습니다.</p>
<a class="header" href="print.html#독립 검사기" id="독립 검사기"><h3>독립 검사기</h3></a>
<p>독립 검사기를 설치하려면 먼저 <a href="https://www.rust-lang.org/install.html">러스트를 설치</a>한 뒤(1.15 이상이 필요합니다), 다음을 입력합니다.</p>
<pre><code>cargo install -f kailua
</code></pre>
<p>(<code>-f</code>는 이미 설치된 검사기도 함께 업그레이드 해 줍니다.)</p>
<p><code>kailua check &lt;검사를 시작할 파일 경로&gt;</code>로 실행할 수 있습니다.</p>
<p><img src="res/kailua-check.png" alt="" /></p>
<p>또한 <code>kailua.json</code>이나 <code>.vscode/kailua.json</code>이 해당 디렉토리에 있다면 <code>kailua check &lt;검사할 디렉토리 경로&gt;</code>로 실행할 수도 있습니다. 설정 파일의 포맷은 이 문서의 뒷부분을 참고하세요.</p>
<a class="header" href="print.html#visual studio code" id="visual studio code"><h3>Visual Studio Code</h3></a>
<p>카일루아는 <a href="https://code.visualstudio.com/">Visual Studio Code</a>에서 IDE로 사용할 수 있습니다. 빠른 실행(<code>Ctrl-P</code>)에서 <code>ext install kailua</code>를 입력해서 설치합니다. <strong>윈도 이외의 환경에서는 앞에서 설명된 대로 독립 검사기를 먼저 설치해야 합니다.</strong></p>
<p>루아 코드를 포함하는 폴더를 열면 설정 파일을 찾을 수 없다는 오류가 나옵니다. 이 설정 파일은 실시간으로 검사를 수행하는 데 필요합니다.</p>
<p><img src="res/kailua-vsc-missing-config.png" alt="" /></p>
<p><code>.vscode/kailua.json</code>을 직접 만들어도 되고, 명령 팔레트(<code>Ctrl-Shift-P</code>)에서 &quot;Kailua&quot;로 찾아 설정 파일을 수정할 수도 있습니다.</p>
<p><img src="res/kailua-vsc-edit-config.png" alt="" /></p>
<p>수동으로 편집할 경우 <code>.vscode/kailua.json</code>에 다음 내용이 필요합니다.</p>
<!-- what Kailua really supports is not exactly JSON5, but probably it's closer than JSON. -->
<pre><code class="language-json5">{
    &quot;start_path&quot;: &quot;&lt;검사를 시작할 파일 경로&gt;&quot;,

    &quot;preload&quot;: {
        // 아래는 우리가 루아 5.1와 모든 기본 라이브러리를 사용함을 나타냅니다.
        &quot;open&quot;: [&quot;lua51&quot;],
    },
}
</code></pre>
<p>설정 파일을 적용하려면 <code>Ctrl-R</code>로 현재 창을 새로 로드해야 합니다.</p>
<a class="header" href="print.html#첫 카일루아 코드" id="첫 카일루아 코드"><h3>첫 카일루아 코드</h3></a>
<p>시작점을 지정했으면 첫 카일루아 코드를 작성해 보죠.</p>
<pre><code class="language-lua">--# open lua51
print('Hello, world!')
</code></pre>
<p>설정 파일을 사용하고 있다면 좀 더 간단한 코드도 가능합니다.</p>
<pre><code class="language-lua">print('Hello, world!')
</code></pre>
<p>이 코드를 잠시 가지고 건드려 보면서 카일루아가 어떤 오류를 잡아 낼 수 있는지 확인해 보세요.</p>
<a class="header" href="print.html#지원되는 ide 기능들" id="지원되는 ide 기능들"><h3>지원되는 IDE 기능들</h3></a>
<ul>
<li>
<p>실시간 문법 체크 (모든 파일)</p>
</li>
<li>
<p>실시간 타입 체크 (주어진 시작 경로로부터만 가능)</p>
</li>
<li>
<p>이름 및 필드의 자동 완성</p>
</li>
<li>
<p>함수 서명 도움말</p>
</li>
<li>
<p>수식의 타입에 대한 정보 (마우스 커서를 위에 올렸을 경우)</p>
</li>
<li>
<p>지역 및 전역 변수의 정의로 이동하기</p>
</li>
<li>
<p>프로젝트 전체에서 지역 및 전역 변수의 이름을 바꾸기</p>
</li>
</ul>
<a class="header" href="print.html#카일루아 언어" id="카일루아 언어"><h2>카일루아 언어</h2></a>
<a class="header" href="print.html#특별한 주석" id="특별한 주석"><h3>특별한 주석</h3></a>
<p>카일루아는 올바른 루아 코드의 부분집합으로 별도의 변환 작업이나 컴파일이 필요 없습니다. 추가된 것들은 특별한 주석에 쓰여 있습니다.</p>
<ul>
<li>
<p><code>--: &lt;타입&gt;</code>은 앞에 나오는 것의 타입(들)을 지정합니다.</p>
<p>이 주석은 새 이름이 정의될 수 있는 모든 곳에서 쓰일 수 있습니다. 여기에는 <code>local</code>(개별 이름 또는 문장 뒤), <code>function</code>(인자 뒤), <code>for</code>(개별 이름 뒤) 및 대입문(개별 이름 또는 문장 뒤)이 포함됩니다.</p>
<p>이름 뒤에 쓰일 경우에는, 타이핑의 편의를 위해 다음과 같이 콤마나 닫는 괄호를 주석 <em>앞</em>으로 옮길 수 있습니다.</p>
<pre><code class="language-lua">function f(x, --: integer
           y, --: integer
           z) --: integer
    -- ...
end
</code></pre>
<p>여러 이름을 선언하는 흔한 경우에는 문장 뒤에 여러 타입을 지정할 수 있으며, 이 경우 각 타입은 쉼표로 구분됩니다.</p>
</li>
<li>
<p><code>--&gt; &lt;타입&gt;</code>은 함수의 반환 타입을 지정합니다.</p>
<p>이 주석은 함수 인자를 닫는 괄호 뒤에서만 쓰일 수 있으며, 마지막 인자에 대응하는 <code>--:</code>와 <code>--&gt;</code>는 같은 줄에 쓰일 수 있습니다.</p>
</li>
<li>
<p><code>--v function(&lt;이름&gt;: &lt;타입&gt; ...) [--&gt; &lt;타입&gt;]</code>은 함수 타입을 지정합니다.</p>
<p>이 주석은 <code>function</code> 예약어 앞에 올 수 있습니다(네, 익명 함수에도 쓰일 수 있습니다). <code>--:</code>와 <code>--&gt;</code>를 쓰는 것과 동일하나 훨씬 읽기 쉽습니다. 모든 이름은 대응되는 선언과 일치해야 합니다. 가변 인자는 인자 목록 맨 뒤에 <code>...: &lt;타입&gt;</code>과 같이 쓸 수 있습니다. 반환값이 여럿이면 괄호를 쳐야 합니다.</p>
<p>기본적으로 앞의 맥락에서 분명하지 않은 한 모든 함수는 <code>--v</code>나 <code>--:/--&gt;</code>를 써서 타입이 지정되어야 합니다. 따라서 <code>f(function(a, b) ... end)</code>와 같은 코드는 허용되지만, <code>f</code>가 그러한 함수를 받는다고 알려져 있을 때만 가능합니다.</p>
</li>
<li>
<p><code>--v method(&lt;이름&gt;: &lt;타입&gt; ...) [--&gt; &lt;타입&gt;]</code>은 메소드 타입을 지정합니다.</p>
<p><code>function</code>과 동일하나 <code>function A:b(...)</code> 같은 선언에 씁니다. 카일루아는 <code>self</code>의 타입을 추론하려 하며, 그게 불가능할 경우 <code>function A.b(self, ...)</code>와 <code>--v function(...)</code>으로 명시적인 타입을 지정해야 합니다.</p>
</li>
<li>
<p><code>--# ...</code>은 타입 검사기에게 내리는 특별한 명령입니다.</p>
<p>가장 중요한 명령으로는 <code>--# open &lt;내장 라이브러리 이름&gt;</code>이 있는데, 이는 대응되는 내장된 이름들을 읽어 들이면서 앞으로 어떤 언어 변종을 쓸지를 결정합니다. 현재 지원되는 유일한 내장 라이브러리는 <code>lua51</code>(무수정 루아 5.1) 뿐입니다. 시작점이 되는 파일의 주석이 아닌 첫 줄에 이 명령을 두는 게 좋습니다.</p>
<p><code>--# type [local | global] &lt;이름&gt; = &lt;타입&gt;</code>은 타입 별명을 짓는데 쓰입니다. 세 종류의 타입 별명이 있습니다. <code>local</code>은 (<code>local</code> 문장 같이) 새 지역 이름을 만들고, <code>global</code>은 (<code>A = ...</code> 같이) 전역 이름을 만들며, 아무 것도 없을 경우 타입이 현재 파일로부터 <em>내보내져서</em>, <code>require</code>를 할 때 그 위치에서 지역 이름으로 쓸 수 있게 됨을 뜻합니다. 최상위 영역이 아닌 위치에서는 지역 타입만 만들 수 있습니다. 변수 이름과는 달리, 안쪽에 있는 타입 이름이 바깥의 이름을 덮어 씌울 수는 없습니다.</p>
<p><code>--# assume [global] &lt;이름&gt;: &lt;타입&gt;</code>은 주어진 이름의 타입을 <em>덮어 씌웁니다</em>. <code>global</code> 예약어가 있으면 전역 이름을 가리키고, 아니면 <code>local</code>처럼 새 지역 이름이 생깁니다. 검사기를 통과할 수 없는 경우를 해소하는 데 쓸 수 있지만 매우 위험하므로, <strong>조심해서 쓰십시오.</strong></p>
<p>추후에 다른 명령들이 추가될 수 있습니다.</p>
</li>
</ul>
<p>같은 종류의 특별한 주석들은 여러 줄로 나눠 쓸 수 있습니다.</p>
<pre><code class="language-lua">--# type Date = {
--#     hour: integer;
--#     min: integer;
--#     sec: integer;
--# }
</code></pre>
<a class="header" href="print.html#타입" id="타입"><h3>타입</h3></a>
<p>다음 기본 타입들이 인식됩니다.</p>
<ul>
<li>
<p><code>nil</code>, <code>boolean</code>(또는 <code>bool</code>), <code>number</code>, <code>string</code>, <code>function</code>, <code>userdata</code>, <code>thread</code>, <code>table</code>은 모두 기본 루아 타입을 가리킵니다.</p>
</li>
<li>
<p><code>integer</code>(또는 <code>int</code>)는 <code>number</code>이면서 검사 시간에 정수라고 판단할 수 있는 부분집합입니다. (나중에 루아 5.3 이상 지원이 들어갈 경우 기본 타입으로도 쓰일 예정입니다.)</p>
</li>
<li>
<p><code>true</code>나 <code>false</code>, 정수, 그리고 문자열 리터럴은 각각 <code>boolean</code>, <code>integer</code> 및 <code>string</code>의 서브타입입니다.</p>
</li>
<li>
<p>테이블 타입은 네 종류의 유용한 경우로 나뉩니다.</p>
<p>중요한 사항으로, 앞의 두 경우는 자동으로 추론되지 않기 때문에 <code>local tab = {} --: vector&lt;integer&gt;</code>처럼 명시적으로 타입을 지정해야 합니다.</p>
<ul>
<li>
<p><code>vector&lt;T&gt;</code>는 연속된 정수 키를 가지는 테이블 타입입니다.</p>
</li>
<li>
<p><code>map&lt;Key, Value&gt;</code>는 같은 키 타입과 값 타입을 가지는 테이블 타입입니다.</p>
</li>
<li>
<p><code>{ key1: T1, key2: T2 }</code>는 모든 키가 문자열이고 검사 시간에 알 수 있는 레코드입니다. 쉼표 대신에 세미콜론을 쓸 수 있습니다.</p>
<p>명시적으로 선언된 레코드는 기본적으로 &quot;확장될 수 없으며&quot;, 이는 필드 목록이 완전하고 더 이상 수정될 수 없음을 뜻합니다. 필드 목록 뒤에 <code>...</code>를 써서 레코드를 확장 가능하게 만들면 <code>table.field = 'string'</code>과 같이 레코드를 느긋하게 초기화할 수 있습니다. 반대로 일반적인 루아 테이블은 암묵적으로 확장 가능한 레코드 타입을 가지며, 필요할 때만 확장 불가능하게 바뀝니다.</p>
</li>
<li>
<p><code>{ T1, T2, T3 }</code>은 모든 키가 연속된 정수인 튜플입니다. 이것만 빼면 레코드와 유사합니다.</p>
</li>
</ul>
</li>
<li>
<p><code>function(Arg, ...)</code>나 <code>function(Arg, ...) --&gt; Ret</code>는 함수 타입입니다. 반환 타입 <code>Ret</code>은 여러 타입일 수 있으며, 이 경우 괄호로 감싸야 합니다(<code>function(vector&lt;T&gt;, integer) --&gt; (integer, string)</code>).</p>
</li>
<li>
<p><code>T | T | ...</code>는 합(union) 타입입니다. 이 타입은 여러 리터럴 중 하나일 수 있는 타입에 유용합니다(예: <code>&quot;read&quot; | &quot;write&quot; | &quot;execute&quot;</code>). 다른 종류의 합 타입도 가능하나, 카일루아에서 이들 타입의 검사는 거의 지원되지 않습니다.</p>
</li>
<li>
<p><code>any</code>에는 어떤 타입 정보도 없으며, 유용하게 쓰려면 <code>--# assume</code> 명령이 필수적입니다.</p>
</li>
<li>
<p><code>WHATEVER</code>(대문자 주의)는 타입 검사기가 항상 허용하는 <em>구멍</em>입니다. <code>map&lt;integer, WHATEVER&gt;</code>와 <code>map&lt;WHATEVER, string&gt;</code>은 호환되지만, <code>map&lt;integer, WHATEVER&gt;</code>와 <code>map&lt;string, string&gt;</code>은 호환되지 않습니다. 타입 검사의 기본을 뒤흔드는 타입이므로 <strong>조심해서 쓰십시오.</strong></p>
</li>
</ul>
<p>카일루아 타입은 기본적으로 <em><code>nil</code> 검사를 하지 않습니다</em>. 즉, <code>integer</code>에 <code>nil</code>을 대입할 수 있는데 <code>integer</code> 두 개를 더하는 것도 가능하며, 따라서 올바른 카일루아 코드도 실행 시간에 오류가 날 수 있습니다. 이 결정은 원래 언어를 고치지 않으면서 실용적인 타입 검사기를 만드는 데 필요했습니다.</p>
<p>만약 명시적으로 쓰길 원한다면 다른 두 개의 <code>nil</code> 검사 모드를 쓸 수 있습니다. 이 타입들은 (바로는 아니지만) 서로 자유롭게 대입이 가능하므로, 기계가 읽을 수 있는 문서라고 생각하시길 바랍니다.</p>
<ul>
<li>
<p><code>T?</code>는 <code>nil</code>을 대입할 수 있지만 자신이 <code>nil</code>을 가질 수 있다는 걸 알고 있는 타입입니다. 따라서 <code>integer?</code> 두 개는 더할 수 없습니다. 또한 생략 가능한 필드나 인자를 지정하려면 무조건 이 타입을 써야 합니다. <code>{a: integer?, b: integer}</code> 타입은 <code>{a = 42, b = 54}</code>나 <code>{b = 54}</code>를 담을 수 있지만, <code>{a = 42}</code>는 안됩니다.</p>
</li>
<li>
<p><code>T!</code>는 <code>nil</code>이 들어갈 수 없다는 걸 보장합니다.</p>
</li>
</ul>
<p>당연한 이유로, 테이블의 값은 항상 <code>T</code> 또는 <code>T?</code>가 됩니다.</p>
<p>마지막으로, 이름이나 테이블 값에 해당하는 타입 앞에는 <code>const</code>가 붙을 수 있습니다. <code>const</code> 타입의 내부는 변경할 수 없습니다(예: <code>map&lt;integer, const vector&lt;string&gt;&gt;</code>). 하지만 <code>const</code> 타입에 대입하는 건 가능합니다(아니면 쓸모가 없겠지요).</p>
<a class="header" href="print.html#타입 검사기를 피하기" id="타입 검사기를 피하기"><h3>타입 검사기를 피하기</h3></a>
<p>모든 곳에 타입을 다는 것이 실용적이진 않으므로, 카일루아는 지역적으로 타입 검사를 피하는 두 가지 방법을 제공합니다.</p>
<ul>
<li>
<p><code>--v [NO_CHECK] function(...)</code>은 뒤따르는 함수의 타입 검사를 비활성화합니다.</p>
<p>카일루아가 주어진 함수 타입을 <em>믿어야</em> 하므로, 해당 타입은 생략될 수 없습니다.</p>
</li>
<li>
<p>무슨 파일이 검사되는지를 <code>.kailua</code> 파일로 덮어 씌울 수 있습니다.</p>
<p><code>require()</code>가 검사 시간에 확인되는 문자열로 호출될 경우 카일루아는 <code>package.path</code>와 <code>package.cpath</code>에 설정된 값을 사용합니다. <code>package.path</code>의 경우 파일 <code>F</code>를 읽기 전에 <code>F.kailua</code>를 먼저 읽어 봅니다. <code>package.cpath</code>의 경우 파일 <code>F</code>는 아마 실행 파일일테니 <code>F.kailua</code>만 읽습니다. (검색 경로에 <code>?</code>라고 써 놓은 게 아닌 이상 이런 파일들에는 두 개의 확장자 <code>.lua.kailua</code>가 붙게 됩니다.)</p>
<p><code>.kailua</code> 파일에는 원래 대응되는 코드가 주어진 타입을 가지고 있다고 <em>가정</em>하기 위해 <code>--# assume</code> 명령을 많이 쓰게 됩니다.</p>
</li>
</ul>
<a class="header" href="print.html#설정 포맷" id="설정 포맷"><h2>설정 포맷</h2></a>
<p>카일루아의 정확한 동작은 <code>kailua.json</code> 파일에 옵션으로 설정할 수 있습니다. 이 파일은 JSON 파일이지만 편의를 위해 주석(<code>//</code>)을 지원하고, 배열과 오브젝트 맨 뒤에 쉼표가 따라 붙을 수 있습니다:</p>
<pre><code class="language-json5">{
    // 어디서 검사를 시작할 지 나타냅니다. 생략될 수 없습니다.
    //
    // 하나의 문자열이나 문자열 배열이 될 수 있습니다. 배열일 경우, 여러 시작 경로들에서
    // 각각 (하지만 가능할 경우 병렬로) 검사가 진행됩니다. 각 검사 세션은 다른 세션과
    // 독립적이지만 오류 등은 병합되어 보고됩니다.
    &quot;start_path&quot;: [&quot;entrypoint.lua&quot;, &quot;lib/my_awesome_lib.lua&quot;],

    // `package.path`와 `package.cpath` 변수의 값을 나타냅니다.
    // 이 경로는 항상 기준 디렉토리(`.vscode`나 `kailua.json`을 담는 디렉토리)에 상대적입니다.
    // 정확한 포맷은 루아 설명서를 참고하세요.
    //
    // 설정 파일에서는 `{start_dir}` 문자열을 쓰면 *현재* 시작 경로를 담은 디렉토리로
    // 치환됩니다. 따라서 만약 시작 경로가 `foo/a.lua`와 `bar/b.lua` 두 개라면,
    // `{start_dir}/?.lua`는 각 시작 경로에 대해 `foo/?.lua`와 `bar/?.lua`로 확장됩니다.
    // 이 기능은 여러 프로젝트를 각자의 디렉토리에 넣고 일부 공통되는 파일만
    // 공유하고 싶을 때 유용합니다.
    //
    // 만약 여기서 명시적으로 설정되지 않았을 경우, 이들 설정은 `package.path`와
    // `package.cpath`에 설정되는 값으로부터 추론됩니다. 이 동작은 스크립트에서는
    // 편리할 수 있으나 라이브러리와 같이 다른 경우 꽤 귀찮을 것입니다.
    //
    // 또한 카일루아는 `package_cpath`에 있는 어떤 경로도 읽지 않음에 유의하세요.
    // 해당 경로에 대응되는 `.kailua` 파일만 읽게 됩니다.
    &quot;package_path&quot;: &quot;?.lua;contrib/?.lua&quot;,
    &quot;package_cpath&quot;: &quot;native/?&quot;,

    // 검사 전에 검사 환경을 초기화하기 위한 옵션들입니다.
    // 각 옵션은 아래 나와 있는 순서대로 실행되고, 배열 안에서는 주어진 순서대로 실행됩니다.
    &quot;preload&quot;: {
        // `--# open` 인자들의 목록.
        &quot;open&quot;: [&quot;lua51&quot;],
        // `require()` 인자들의 목록. `package_*` 옵션의 영향을 받습니다.
        &quot;require&quot;: [&quot;depA&quot;, &quot;depB.core&quot;],
    },
}
</code></pre>
<!-- -->
<a class="header" href="print.html#클래스 시스템" id="클래스 시스템"><h1>클래스 시스템</h1></a>
<p>루아는 일반적으로 클래스를 포함한 객체지향 기능을 직접 지원하지는 않습니다. 대신 루아는 클래스 시스템을 설계하는 어려운 일을 사용자(또는 라이브러리 저자)에게 맡깁니다. 덕분에 다양한 <strong>클래스 시스템</strong>이 널리 쓰이고 있으며, 카일루아가 뭘 지원하든 이 모든 클래스 시스템의 기능을 제공해야만 합니다.</p>
<p>이는 불가능에 가깝기 때문에, 카일루아는 사용자 지정 가능한 클래스 시스템을 지원합니다. 현재 이 기능은 초기 개발 단계이며 모든 가능한 기능이 구현되어 있지 않은데, 보통 어떤 기능이 사용되는지 분석을 하지 못 하기 때문에 그렇습니다. 다른 클래스 시스템의 분석 및 제안은 언제나 환영합니다.</p>
<a class="header" href="print.html#클래스 시스템의 선언" id="클래스 시스템의 선언"><h2>클래스 시스템의 선언</h2></a>
<p>현재 세션에서 사용 가능한 클래스 시스템은 고유한 전역 이름으로 구분되며, 명시적으로 선언되어야 합니다.</p>
<pre><code class="language-lua">--# class system gideros
</code></pre>
<p>현재 각 클래스 시스템의 이름은 고정이며 다음 목록에서 골라야 합니다.</p>
<table><thead><tr><th> 이름 </th><th> 설명 </th><th> 상속 지원 </th><th> <code>[make_class]</code> </th></tr></thead><tbody>
<tr><td> <code>gideros</code> </td><td> <a href="classes-gideros.html">기데로스 클래스 시스템</a> </td><td> 단일 </td><td> 지원 </td></tr>
</tbody></table>
<a class="header" href="print.html#클래스의 선언" id="클래스의 선언"><h2>클래스의 선언</h2></a>
<p>클래스는 두 가지 방법으로 선언할 수 있습니다.</p>
<ol>
<li><code>--# assume class</code> 명령은 이미 존재하는 클래스를 선언 및 가정(assume)할 수 있습니다.</li>
<li>클래스 시스템이 지원할 경우, <code>[make_class(&lt;class system&gt;)]</code> 속성을 가진 함수가 호출될 때마다 새 클래스가 생성됩니다.</li>
</ol>
<a class="header" href="print.html#-- assume class 명령" id="-- assume class 명령"><h3><code>--# assume class</code> 명령</h3></a>
<p><code>--# assume class</code> 명령은 클래스 시스템에 소속되지 않은 클래스를 만들 수 있습니다. 이는 상속을 쓰지 않고 특별한 의미론이 붙지 않은 간단한 클래스를 선언하는 데 유용합니다.</p>
<pre><code class="language-lua">-- 전역 변수 `Hello`를 새로 선언된 전역 클래스 `Hello`의
-- 프로토타입으로 선언함

--# assume global class Hello
</code></pre>
<p>이는 단순한 명령이기 때문에(즉 루아는 무시할 것이기 때문에), <code>global</code>이 없이 선언된 지역 클래스는 해당 이름이 이미 지역 변수여야만 합니다.</p>
<pre><code class="language-lua">local Hello = {}
--# assume class Hello
</code></pre>
<p>클래스 시스템이 있다면 괄호로 묶여야 합니다. 클래스 시스템이 상속을 지원할 경우 부모 클래스도 지정할 수 있습니다.</p>
<pre><code class="language-lua">--# assume global class(gideros) Object
--# assume global class(gideros) Sprite: Object
</code></pre>
<p>일반적으로 서로 다른 클래스 시스템, 그리고 클래스 시스템에 소속된 클래스와 그렇지 않은 클래스는 서로 상호작용할 수 없습니다.</p>
<a class="header" href="print.html#make_class 속성" id="make_class 속성"><h3><code>[make_class]</code> 속성</h3></a>
<p><code>[make_class]</code> 속성이 붙은 함수는 일반적인 루아 코드가 새 클래스를 만드는 데 쓰는 방법과 비슷합니다. 이 속성은 클래스 시스템에 소속된 클래스에만 쓸 수 있으며, 다음과 같이 <code>--# assume</code> 되거나...</p>
<pre><code class="language-lua">--# assume global `class`: [make_class(gideros)] function() --&gt; table
</code></pre>
<p>또는 함수 명세와 함께 명시적으로 선언될 수 있습니다:</p>
<pre><code class="language-lua">--v [NO_CHECK] -- 클래스의 내부 구현은 체크하기 어려우므로
--v [make_class(gideros)]
--v function() --&gt; table
function make_class()
    -- ...
end
</code></pre>
<p>많은 경우 이 함수를 인자 없이 호출하면 명시적인 부모 클래스가 없는 새 클래스를 선언하게 되고, 부모 클래스 프로토타입을 인자로 넘겨 주면 상속으로 처리됩니다. 정확한 동작과 인자들의 해석은 물론 클래스 시스템마다 다를 수 있습니다.</p>
<p><code>[make_class]</code> 함수가 반환한 새 클래스 프로토타입은 최대한 빨리 변수에 대입되어야 합니다. 이 때가 바로 클래스에 이름이 붙는 때입니다:</p>
<pre><code class="language-lua">local Hello = class() -- 지역 타입 `Hello`를 함께 정의

Sprite = class() -- 전역 타입 `Sprite`를 함께 정의
</code></pre>
<p>몇 가지 꼼수로 이름이 없는 클래스를 사용할 수는 있지만 권장하지는 않습니다. 이러한 클래스 또한 오류 메시지 등에서는 유일하게 지칭됩니다.</p>
<a class="header" href="print.html#필드와 메소드의 선언" id="필드와 메소드의 선언"><h3>필드와 메소드의 선언</h3></a>
<p>일단 클래스가 선언되면, 클래스 시스템의 자체적인 제한에 걸리지 않는 한 필드와 메소드를 자유롭게 추가할 수 있습니다:</p>
<pre><code class="language-lua">--# assume global class Person

--v function(name: string) --&gt; Person
function Person.new(name)
    local person = {}
    set_metaclass_for_person(person) -- 이 부분은 여러분에게 맡깁니다
    --# assume person: Person

    person.name = name -- 새 필드를 정의
    return person
end

-- 새 클래스 필드를 선언
Person.HELLO = 'Hello'

-- 새 메소드를 선언 (메소드는 사실 `self`를 받는 함수가 들어간 클래스 필드이므로)
--v method()
function Person:greet()
    print(self.HELLO .. ', ' .. self.name)
end

local person = Person.new('J. Random Hacker')
person:greet()
</code></pre>
<p>여기서 볼 수 있듯,</p>
<ul>
<li>
<p>클래스 시스템이 없을 경우 새 인스턴스 타입을 만들려면 무조건 <code>--# assume</code>이 필요합니다. 한편 클래스 시스템은 보통 생성자로부터 <code>new</code> 메소드 같은 걸 자동으로 만드는 기능이 있을 겁니다.</p>
</li>
<li>
<p>인스턴스 필드는 대입문으로 만들 수 있습니다. 하지만 없는 필드를 읽는 건 여전히 오류이므로, 만약 위에서 <code>name</code> 필드를 설정한 <em>뒤에</em> <code>person</code> 변수의 타입을 바꿔 치웠다면 타입 체커는 <code>name</code> 필드의 존재를 알 수 없을 것입니다.</p>
</li>
<li>
<p>메소드는 함수와 같은 문법으로 선언할 수 있지만 <code>function</code> 대신 <code>method</code> 예약어를 쓰고 <code>self</code> 인자는 생략(되며 자동으로 추론)됩니다.</p>
</li>
</ul>
<p><code>--# assume</code>은 클래스에도 쓸 수 있습니다. 만약 이미 존재하는 클래스에 타입만 붙이는 거라면 위의 코드는 다음과 같이 다시 쓸 수 있습니다:</p>
<pre><code class="language-lua">--# assume global class Person
--# assume static Person.new: function(name: string) --&gt; Person
--# assume static Person.HELLO: string
--# assume Person.greet: method()

local person = Person.new('J. Random Hacker')
person:greet()
</code></pre>
<p>이는 보통의 <code>--# assume</code>과 같으나 몇 가지 차이점에 주의하세요:</p>
<ul>
<li>
<p><code>Person.greet</code>는 기술적으로는 <code>Person</code>을 첫 인자로 가지는 <code>static</code> 함수여야 할 겁니다. <code>method</code> 예약어는 편의를 위해서 제공됩니다. (<code>method</code>로 시작하는 타입은 없습니다.)</p>
</li>
<li>
<p>전역에 선언된 클래스의 필드는 최상위 블록에서만 <code>--# assume</code> 할 수 있습니다. 이는 <code>--# assume</code>은 일반적으로 현재의 지역 스코프에 해당 이름의 복사본을 생성하는데, 새 필드를 만드는 건 클래스에 전역적으로 영향을 주기 때문입니다.</p>
</li>
<li>
<p>클래스 시스템에 따라서는 어떤 필드는 아예 정의를 할 수 없을 수도 있습니다.</p>
</li>
</ul>
<!-- TODO: mention that the classes prototypes are automatically subject to delayed type checking (needs to explain this first) -->
<a class="header" href="print.html#기데로스 지원" id="기데로스 지원"><h1>기데로스 지원</h1></a>
<p><code>gideros</code> 클래스 시스템은 <a href="http://docs.giderosmobile.com/classes_in_gideros.html">기데로스 클래스</a>의 동작을 모방합니다. 이 클래스 시스템은, 물론 이미 필요했다는 사실은 차치하고, 너무 단순하게 설계되어 타입 체킹에서 문제가 될 수 있는 흔한 예제라 선택되었습니다.</p>
<p>다음은 <code>gideros</code> 클래스 시스템에서 흔히 쓰이게 될 초기 선언입니다.</p>
<pre><code class="language-lua">--# class system gideros
--# assume global class(gideros) Object
--# assume global Core: {}
--# assume Core.class: [make_class(gideros)] function(parent: table?) --&gt; table
</code></pre>
<p>이 명령들은 <code>Object</code> 최상위 클래스와, 클래스를 생성해 내는 <code>Core.class</code> 함수를 선언합니다.</p>
<a class="header" href="print.html#생성자" id="생성자"><h2>생성자</h2></a>
<p><code>init</code> 메소드가 선언되면 자동으로 <code>new</code> 메소드도 함께 생성됩니다.</p>
<pre><code class="language-lua">--# assume global class(gideros) Foo: Object

--v method(text: string)
function Foo:init(text)
    self.text = text
end

local x = Foo.new('string')
</code></pre>
<p>참고로, 현재 실제로 <code>new</code> 메소드가 생성되는 시점은 <code>new</code>가 처음으로 불렸을 때입니다. 따라서 오류가 <code>init</code>의 선언보다 늦어져서 사용하는 위치에서 날 수 있습니다.</p>
<a class="header" href="print.html#상속" id="상속"><h2>상속</h2></a>
<p>기데로스 클래스 시스템은 단일 상속을 지원하며, <a href="classes.html">이전 장</a>에서 설명한 일반적인 문법과 동작을 따릅니다.</p>
<p>자식 클래스에서 선언된 필드는 부모 클래스에서 이미 선언된 필드를 단순히 감추게 되는데, 이를 제약하지 않으면 서브타이핑(부모 클래스를 예상하는 곳에 자식 클래스를 쓸 수 있는 기능)이 깨지게 됩니다. 따라서 <strong>카일루아에서 필드들은 일반적으로 오버라이딩할 수 없습니다.</strong> 다만 생성자(<code>init</code>)에 한해서 오버라이딩이 가능한데, 대신 생성자는 인스턴스를 통해서는 접근할 수 없습니다.</p>
<p>기데로스에서 모든 클래스는 <code>Object</code> 최상위 클래스의 자식으로 가정됩니다. <strong>카일루아는 부모 클래스 없이 선언된 첫번째 (그리고 마지막) 클래스를 인식하며 그러한 클래스가 여럿 생기는 걸 금지합니다.</strong> <code>Core.class</code> 함수는 부모 클래스가 없을 경우 <code>Object</code>를 대신 쓸 것입니다. 하지만 이런 경우가 아니라면 암묵적인 동작이 혼란스럽기 때문에, <code>--# assume class</code>의 경우 부모 클래스가 <code>Object</code>더라도 무조건 명시적으로 제시해야 합니다.</p>
<a class="header" href="print.html#카일루아의 내부 동작" id="카일루아의 내부 동작"><h1>카일루아의 내부 동작</h1></a>
<p>카일루아는 <a href="https://rust-lang.org/">Rust</a> 애플리케이션입니다. 당분간은 <a href="docs.rs">docs.rs</a>에 있는 생성된 문서를 사용해 주세요:</p>
<ul>
<li><a href="https://docs.rs/kailua_env/"><code>kailua_env</code></a></li>
<li><a href="https://docs.rs/kailua_diag/"><code>kailua_diag</code></a></li>
<li><a href="https://docs.rs/kailua_test/"><code>kailua_test</code></a></li>
<li><a href="https://docs.rs/kailua_syntax/"><code>kailua_syntax</code></a></li>
<li><a href="https://docs.rs/kailua_types/"><code>kailua_types</code></a></li>
<li><a href="https://docs.rs/kailua_check/"><code>kailua_check</code></a></li>
<li><a href="https://docs.rs/kailua_workspace/"><code>kailua_workspace</code></a></li>
<li><a href="https://docs.rs/kailua_langsvr/"><code>kailua_langsvr</code></a></li>
<li><a href="https://docs.rs/kailua_langsvr_protocol/"><code>kailua_langsvr_protocol</code></a></li>
<li><a href="https://docs.rs/kailua/"><code>kailua</code></a></li>
</ul>
<a class="header" href="print.html#라이선스" id="라이선스"><h1>라이선스</h1></a>
<p>Copyright © 2015–2017 Nexon Corporation. All rights reserved.</p>
<p>카일루아는 <a href="https://github.com/devcat-studio/kailua/blob/master/LICENSE-MIT">MIT 라이선스</a>와 <a href="https://github.com/devcat-studio/kailua/blob/master/LICENSE-APACHE">아파치 라이선스 2.0</a>으로 라이선스되어 있으며 둘 중 하나를 선택할 수 있습니다. 카일루아에 기여하면 기여된 내용이 이 두 라이선스로 라이선스된다는 데 동의하게 됩니다.</p>
<p>카일루아의 원 개발자는 <a href="https://devcat.nexon.com/">데브캣 스튜디오</a>의 <a href="https://mearie.org/">강 성훈</a>이며 프로젝트 메인테이너로 남아 있습니다.</p>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        


        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
